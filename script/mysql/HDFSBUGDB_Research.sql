insert into HDFSBUGDB.Research (id, IssueInfo_id, Cause, Impact, Link)
values  (1, 1, 'OpenSSL库从OpenSSL版本1.1.0开始从eay32重命名为libcrypto', '标准化跨平台使用OpenSSL失败', ''),
        (2, 2, 'Datanode的块汇报分为IBR(增量块汇报)和FBR(全量块汇报),Namenode重启的时候,会发送 DNA_REGISTER 命令给Datanode,Datanode收到后,异步运行#reRegister,由于是异步运行,无法确定发送FBR和清除IBR哪个先运行。如果先发送FBR然后清除IBR,就会在这两个时间点之间丢失一些块,直到下一个FBR。', '如果打开 processCommand 异步功能,Namenode 重新启动时缺少 IBR,即Namenode重新启动后丢失块', 'HDFS-14997'),
        (3, 3, 'Dirty buffer 导致重建块失败,Dirty buffer的出现是因为在释放buffer后,StripedBlockReader仍旧保留buffer并且写入内容,导致污染了BufferPool', 'ec重建失败,块丢失', ''),
        (4, 4, '在HDFS-14941之后,global gen stamp的更新在某些情况下被延迟,这使得最后一组增量块报告泄露', 'Namenode无法自行退出安全模式,该模式下Namenode不接收任何对于命名空间的修改操作,同时也不触发任何复制和删除数据块的操作', 'HDFS-14941'),
        (5, 5, 'JournalNodeMXBean是一个公共接口,在某次更新中,添加了getClusterIds()、getClusterIds()、getVersion()三个方法,', '破坏了 3.3.0 和 3.3.1 两个版本之间的源代码兼容性。', 'HDFS-15245'),
        (6, 6, 'TestOfflineEditsViewer.testStored()读取FSEditLogOpCodes的负值失败。', 'edits version太低,需要升级', 'HDFS-15566'),
        (7, 7, '更新中向editLog事务引入了modification time,当NN重启的时候,从editLog文件中读取旧的布局版本,且假设事务也来自先前的版本,因此跳过解析modification time,会级联导致NN关闭.', 'Namenode重新启动失败', 'HDFS-14922、HDFS-14924、HDFS-15054'),
        (8, 9, '加载FSImage时,FileSummary的排序方法错误,导致加载FSImage失败', 'Namenode启动失败', ''),
        (9, 10, 'Namenode初始化的时候检查多次授权API版本', '造成严重的性能下降', ''),
        (10, 11, '新的API INodeAttributeProvider#checkPermissionWithContext()缺少方法体', '旧的实现无法编译', ''),
        (11, 12, 'HDFS-13101引入的代码逻辑错误,当删除大量快照后,解析EditLog失败', 'Namenode解析EditLog失败', 'HDFS-13101'),
        (12, 13, 'The this.removeFeature(..) is getting called two times in InodeDirectory.java.', '重命名快照失败', ''),
        (13, 14, '在windows上,设置Name directory权限失败', 'HDFS NameNode and JournalNode 在windows上启动失败', ''),
        (14, 15, '在升级集群2.X到3.X的时候,需要先升级NN,此时出现NN3.X,但DN2.X的情况,由于代码逻辑的问题,如果 NN 的标识符添加新字段,DN 将丢失字段并计算错误的密码。', 'DN计算出错误的密码', ''),
        (15, 16, 'HDFS-11848向 DistributedFileSystem.listOpenFiles() 添加了一个附加参数,但它不保留现有 API。', '从 Hadoop 2.9.0/2.8.3/3.0.0 升级到 3.0.1/3.1.0 及更高版本时,这可能会导致问题。', '11848'),
        (16, 17, '使用了java.util.concurrent.atomic.LongAccumulator,它只在 JDK8 及更高版本中', '无法兼容JDK7', ''),
        (17, 18, '在没有应用HDFS-14617补丁的情况下,可以加载一个在图像摘要部分列出了子部分的fsimage,因此fsimage sub-sections默认打开', '如果集群被升级到包含该功能的版本,那么在降级时,图像将无法加载', 'HDFS-14617'),
        (18, 19, 'HDFS-10519中引入了必填字段committedTxnId', '如果JN和NN不在同一版本上,出现不兼容内容问题,将遇到缺少字段异常', 'HDFS-10519'),
        (19, 20, 'ec解码存在线程安全性问题', '安全性问题', ''),
        (20, 21, '删除数据时删除了唯一数据块', '块丢失', ''),
        (21, 22, '在没有snapshot的集群环境下,如果想通过生成的xml转回fsimage,会报错。', '修复为ReverseXML处理器不接受没有 SnapshotDiffSection 的 XML 文件', ''),
        (22, 23, 'RAND_pseudo_bytes 在 OpenSSL 1.1.1 中已弃用', '编译错误', ''),
        (23, 24, 'ec算法问题,没有使用正确的参数调用', '在某些情况下,停用Datanode可能会生成全为 0 的奇偶校验块的内容', ''),
        (24, 25, '当 BlockSender 因找不到元数据而抛出异常时,线程获取的卷引用没有被释放。', '试图移除卷的线程等待并陷入死循环,同时由于线程在移除卷时一直持有 checkDirsLock,其他试图获取相同锁的线程将被永久阻塞。', ''),
        (25, 26, 'EC块恢复期间计算安全长度的int溢出', '产生负数和零长度两种情况,前者导致后续的>=0检查失败,BlockRecoveryWorker线程崩溃,恢复操作无法进行完成；后者导致检查通过,直接将块大小为0,导致数据丢失。', ''),
        (26, 28, '将 bzero 替换为 explicit_bzero 以获得更好的安全性', '更好的安全性', ''),
        (27, 29, 'JN套接字超时时间设置太短', '如果 NameNodes 尝试从 JournalNodes 下载一个大的编辑日志(比如几百MB),它可能会超过 10 秒。发生这种情况时,两个 NN 都会崩溃', ''),
        (28, 30, 'CloseOp共享块实例，当SNN滚动Editlog时，TruncateOp不会使文件进入UnderConstruction状态，然后第二个CloseOp运行时，文件不处于该状态，SNN崩溃', '备用Namenode崩溃', ''),
        (29, 31, '不安全的线程问题', 'NameNode发生ConcurrentModificationException错误，并退出。', ''),
        (30, 32, '由 Active Namenode 识别的损坏副本不会由 Other Namenode 识别', '故障转移后Namenode之间的CORRUPT副本不匹配', ''),
        (31, 33, '目前的代码逻辑是如果任何副本在陈旧的存储上，不会立即删除损坏的副本', 'Namenode在故障转移后显示不同的块状态', ''),
        (32, 34, 'Checkpoint检查过于严格，当SNN上传的fsimage与之前的fsimage增量较小时，ANN会拒绝该图像', '导致ANN偶尔会丢失一张图像', ''),
        (33, 35, '当在备用Namenode上排队 IBR（增量块报告）时，一些报告的信息将被现有存储的信息替换', '块损坏', ''),
        (34, 36, ' BPServiceActor 中的线程启动顺序有误，无法保证在启动bpThread之前，lifelineSender已经获取并释放了锁', '调用 hdfs dfsadmin -refreshNamenodes hostname:50020 在联邦环境中注册一个新的命名空间时，DataNode可能会死锁', ''),
        (35, 37, '传给Yetus的配置缺少', 'test4tests seems to be broken for libhdfspp.', ''),
        (36, 38, '在故障转移和管道恢复的情况下，块被标记为 CORRUPT', '来自 Datanode 的 BR 将使块损坏，并且在无效块期间不会删除它', ''),
        (37, 39, '一些protobuf APIs将被启用', '需要替换为新APIs', ''),
        (38, 40, 'libhdfs 和 fuse-dfs 组件中的某些代码区域的目标缓冲区小于尝试写入的源缓冲区。', '这会导致截断。因此，我们需要确保正在写入的源不超过目标缓冲区大小。', ''),
        (39, 41, '在RouterRpcServer中，getListing函数被处理为两部分：1合并来自目标 ns + 路径的所有部分列表2为要列出的目录附加挂载点。在大于 DFSConfigKeys.DFS_LIST_LIMIT（默认值为 1k）的大 dir 的情况下，将使用批处理列表，并使用 startAfter 定义每个批处理列表的边界。', '这里的第2步会添加已有的挂载点，会弄乱batch的边界，从而使得下一个batch startAfter出错。无法列出正确的大目录', ''),
        (40, 43, 'RAND_pseudo_bytes was deprecated in OpenSSL 1.1.1', '需要替换为新版本', ''),
        (41, 44, 'RAND_pseudo_bytes was deprecated in OpenSSL 1.1.1.', '需要替换为新版本', ''),
        (42, 45, 'If this INode is an INodeRefernce , it fails at Preconditions.checkstate as the child is an refernce but we have converted that as file', 'Concat on INodeRefernce fails with illegal state exception', ''),
        (43, 46, 'In the operation of writing EC files, when the client calls addBlock() applying for the second block group (or >= the second block group) and it happens to exceed quota at this time, the client program will hang forever.', '客户端将被永远挂起', ''),
        (44, 47, '查看挂载点的内容摘要，未清空配额，但挂载表存储已清空配额', 'Clear Quota in Router was not consistent', ''),
        (45, 48, '文件在关闭过程中，数据流会试图冲刷所有健康的数据流，但是由于异常，数据流不会有任何结果，数据流会一直卡住。因此，关闭时也会被卡住。', '在文件关闭过程中，如果由于慢速流的关闭而出现异常，并且失败的数据流的数量比奇偶校验块的数量多，那么Ec文件写入就会挂起。', ''),
        (46, 50, '在初始化namenode时，`initAuditLoggers`将被调用，它将尝试调用`org.apache.hadoop.hdfs.server.namenode.top.TopAuditLogger`的默认构造函数，而该构造函数并没有默认构造。因此抛出了 InstantiationException', '配置参数`dfs.namenode.audit.loggers`允许`default`（这是默认值）和`org.apache.hadoop.hdfs.server.namenode.top.TopAuditLogger`。当使用`org.apache.hadoop.hdfs.server.namenode.top.TopAuditLogger`时，namenode将无法成功启动，因为从`org.apache.hadoop.hdfs.server.namenode.FSNamesystem.initAuditLoggers`抛出了`InstantiationException`。', ''),
        (47, 51, '有 2 个带 kdc 的领域。一个领域用于人类用户 (USERS.COM.US),另一个领域用于服务主体(SERVICE.COM.US) 跨领域。在 krb5.conf 中，默认域设置为 SERVICE.COM.US', 'USERS.COM.US领域内的用户不能将任何文件放到Fuse挂载的位置上。', 'HADOOP-9747'),
        (48, 52, 'TestDataNodeVolumeFailureToleration 失败', '单元测试无法清理测试数据并导致未来的 Maven 测试运行崩溃', ''),
        (49, 53, 'JN的线程在ConnectException上不断尝试10次，由于tailing period非常低，不停地重试卡住的线程，堆积如山，导致OOM', '如果JN之一发生故障，Namenode就会崩溃', ''),
        (50, 54, '问题的根源在于，当node.getNumberOfBlocksToBeReplicated()>= replicationStreamsHardLimit（默认为4，可以通过propertydfs.namenode.replication.max-streams-hard-limit来改变）时，它将继续而不更新numReplicas，这将用于scheduleReconstruction方法来判断是否有足够的复制。 max-streams-hard-limit），它将继续而不更新numReplicas，这将用于scheduleReconstruction方法来判断它是否有足够的副本，当它认为ec有足够的副本时，它将从needReconstruction中移除该块，这使得该块永远没有机会重建。', 'EC不会重建丢失的块', ''),
        (51, 55, 'After HADOOP-16314, JWTRedirectAuthenticationHandler is enabled for httpfs in addition to KerberosDelegationTokenAuthenticationHandler, which is set by HttpFSAuthenticationFilter.', '在Trunk上通过httpfs访问HDFS时，出现 Request is a replay (34)错误 ', 'HADOOP-16314'),
        (52, 56, 'ErasureCodingWork.java中有一个问题。例如，有2个节点(dn0, dn1)在退役，一个ec块组有2个节点。在创建一个ErasureCodingWork来重构后，它将创建2个复制的工作。如果dn0复制成功，dn1复制失败，那么它将一直为dn0创建复制工作。dn0上的区块被过度复制，dn1上的区块将永远不会被复制。', '有些区块在ec decommissioning时被过度复制', ''),
        (53, 57, 'Under-Replicated Blocks的数量永远不下降', '丢失的块不能重建，复制的块没有删除', ''),
        (54, 58, '字段timedOutItems(ArrayList类型，非线程安全)，受自身同步保护(timedOutItems)，但是在另一个地方它（试图）通过使用pendingReconstructions进行同步保护——但这不能保护timedOutItems。在不同对象上同步并不能确保与其他位置互斥。', '字段timedOutItems同步错误', ''),
        (55, 59, 'HashMap 不是线程安全的。字段 storageMap 通常由 storageMap 同步。但是，在一个地方，字段 storageMap 不受同步保护。', 'HashMap线程安全问题', ''),
        (56, 60, ' SBN在PendingDataNodeMessages#queueByBlockId MAP中保留未来块IBR消息。这个MAP将数据块作为key，并将replicas作为value。但是在EC的情况下，她应该将数据块作为key，子EC块作为value', '当大量的EC文件被写入时，SBN被重新启动，那么它将永远不会从安全模式中出来，所需的块数也会增加。本质是一种内存泄露', ''),
        (57, 61, 'SBN跟踪已经关闭的编辑日志', 'Appending to EC files crashes NameNode', ''),
        (58, 62, '在重命名操作中计算配额时，我们使用目标目录的存储策略来计算SRC配额的使用。当源路径被设置为存储策略时，这将导致typeConsumed的错误值', '重命名时，带有storagePolicy的源路径导致错误的typeConsumed', ''),
        (59, 63, 'Busy DN replica should be consider in live replica check.', '数据块损坏', ''),
        (60, 64, 'DirectoryScanner需要改进，添加常规文件检查相关块。异常的块文件会导致计算空间异常，它们应该被主动识别和过滤，有利于集群的稳定性', '异常的块文件会导致计算空间异常', ''),
        (61, 65, '性能降低的原因如下：1.ObserverReadProxyProvider尝试为每个读取调用查找 ObserverNode 2.StandbyNode 将getHAServiceState()视为 READ 操作并抛出StandbyException', '当通过ObserverReadProxyProvider启用Observer读取功能，但集群上没有ObserverNodes时，HDFS客户端的性能大幅下降。', ''),
        (62, 66, 'BlockManager代码逻辑问题', '如果一个或多个数据节点在停用期间停止服务，则停用可能会挂起', ''),
        (63, 67, 'NPE的原因是dfs.federation.router.quota.enable=false时Router#quotaManager没有初始化，但是在router内部执行setQuota rpc请求时，我们会在方法Quota#isMountEntry中使用它而不检查null。', '当我们使用dfs.federation.router.quota.enable=false启动路由器并尝试通过它们设置配额时，NullPointerException 被捕获。', ''),
        (64, 68, '用于 sasl 的 retrievePassword 引发了 InvalidToken 异常,缺少相应的处理', '过期的块令牌导致读取速度慢', ''),
        (65, 69, '当 dfs.federation.router.rpc.enable=false 时，routerid 为 null，但 RouterHeartbeatService 需要 updateStateStore() 和 routerId。', '无法运行', ''),
        (66, 70, '如果文件在之前的迭代中被跳过，复制应该包括重命名记录。', '使用snapshot diff的distcp情况下,数据丢失', ''),
        (67, 71, 'DatanodeAdminDefaultMonitor 在异常时双重排队 DatanodeDescriptor 的边缘情况', '导致 DatanodeDescriptor 被两次添加到 pendingNodes 队列中。', ''),
        (68, 72, 'HDFS Namenode 类“DatanodeAdminManager”负责停用数据节点,根据这个“hdfs-site”配置：dfs.namenode.decommission.max.concurrent.tracked.nodes(默认为100），Namenode 在任何给定时间只会主动跟踪最多 100 个数据节点以进行退役，以避免 Namenode 内存压力。', '如果在给定时间有超过 100 个数据节点被停用，存在一种边缘情况，该逻辑会阻止Namenode处理退役，既然该100个节点无法退役，那么其他节点也永远无法退役。', ''),
        (69, 73, 'balancer bug when transfer an EC block', '数据块位置与其索引不匹配', ''),
        (70, 74, 'stats.subtract()和stats.add()不是事务性的', 'Namenode统计信息会出现错误', 'HDFS-14042'),
        (71, 75, '除了第一个块报告之外，不应重置块报告间隔', '目前，即使手动触发 BR 或因 diskError 触发 BR，也会重置 BlockReport 间隔。', ''),
        (72, 76, 'LeaseMonitor守护进程中的try catch语句有一个问题（在LeaseManager.java中），当捕捉到一个未知的异常时，它只是打印出一个警告信息，然后继续下一个循环。一个极端的情况是，当配置项''dfs.namenode.lease-recheck-interval-ms''被用户意外地设置为一个负数，因为配置项被读取而没有检查其范围，''fsnamesystem.getLeaseRecheckIntervalMs()''返回这个值并被作为Thread.sleep()的参数。一个负的参数将导致Thread.sleep()抛出一个IllegalArgumentException，它将被''catch(Throwable e)''所捕获，并打印出一条警告信息。', '这种行为会在每个后续的循环中重复出现。这意味着在短时间内会有大量的重复信息被打印到日志文件中，迅速消耗磁盘空间，影响系统的运行。', ''),
        (73, 77, '当Datanodes拥塞时，客户端进入休眠状态，但不释放dataQueue。ResponseProcessor线程需要''dataQueue''执行''ackQueue.getFirst()''，所以ResponseProcessor会等待客户端释放''dataQueue''，相当于ResponseProcessor线程也进入休眠，导致ACK延迟。', 'MapReduce任务可能会延迟几十分钟甚至几小时', ''),
        (74, 78, 'Due to NPE in the middle, there will be pending moves left in the queue so balancer will stuck forever.', 'Balancer stuck when moving striped blocks due to NPE', ''),
        (75, 79, '在多个namenode的情况下，如果重启了多个namenode，就会失败。由于restartNamenode会检查所有的namenode是否启动，但是如果有2个namenode宕机，我们重启一个，另一个namenode不会启动，所以重启失败。', 'Namenode重启失败', ''),
        (76, 80, '客户端和上游Datanode 在访问 FsDatasetSpi 之前没有 CheckNotNull，因此仅仅知道没有初始化，而不知道nullpointexception的具体原因', '打的日志抛出的异常消息晦涩', ''),
        (77, 86, '它的父类 FileSystemContractBaseTest 设置了 @Rule public Timeout globalTimeout', '即使TestHDFSFileSystemContract.testAppend设置了 @Test(timeout = 60000) ，也不会生效', 'HDFS-16168'),
        (78, 87, 'HDFS-16320之后，DataNode 将从每个 NameNode 检索 SLOW 状态', '由于bug，namenode并没有在DatanodeProtocolServerSideTranslatorPB#sendHeartbeat中将isSlowNode设置为HeartbeatResponseProto。', 'HDFS-16320'),
        (79, 88, '在HDFS-14818中，我们提出了一个补丁来支持检查本地的pmdk库。预期的目标是向用户显示关于pmdk lib加载状态的提示', 'pmdk lib实际上没有被成功加载，但`hadoop checknative`命令仍然告诉用户它被加载了', 'HDFS-14818'),
        (80, 89, 'DataNodeVolumeMetrics 中的 Metric metadataOperationRate 计算错误', '1.导致MetadataOperationRateAvgTime在某些情况下非常大2.导致 Namenode 端出现慢速磁盘指标错误。', ''),
        (81, 90, '截至目前，invokeAtAvailableNs 仅在默认或第一个命名空间不可用时重试一次，尽管有其他命名空间可用。', '优化以重试所有命名空间。', 'HDFS-16359'),
        (82, 91, '代码逻辑问题', 'RouterRpcServer#invokeAtAvailableNs 重试时不生效', 'HDFS-16369'),
        (83, 92, 'datanode锁的错误使用', '调用 dfsadmin -reconfig datanode ip:host start 触发#refreshVolumes 时，DataNode 可能会遇到死锁。', ''),
        (84, 93, 'Namenode$getAdditionalDatanode 返回多个 datanodes ，而不是 DataStreamer.addDatanode2ExistingPipeline 中的一个。 ', 'numOfReplicas 在 BlockPlacementPolicyDefault$chooseTarget 中被赋予错误的值会导致 DataStreamer 因异构存储而失败', ''),
        (85, 94, 'Xattrs 和 Acl 的 SnapshotDiff 行为在 NN 重新启动时与检查点不一致', 'distcp与snapshot diff会失败，出现以下错误:WARN tools.DistCp: The target has been modified since snapshot xxxxx。', 'HDFS-16055'),
        (86, 95, 'Quota is not preserved in snapshot INode', '这会导致INodeDirectory#metadataEquals始终返回 true。因此，snapshotDiff将始终返回已修改的快照根，即使在创建快照之前设置了配额：', 'HDFS-16187'),
        (87, 96, '在 Debian 10 上查找 OpenSSL 似乎存在问题', 'libhdfspp找不到openssl库', 'HDFS-16300'),
        (88, 97, '当启用权限提供程序插件（例如 Ranger）时，在某些情况下它可以抛出 AccessControlException 的子类（例如 RangerAccessControlException）。如果允许此异常向上传播堆栈，则当它解开包含 AccessControlException 子类的远程异常时，它可能会给 HDFS 客户端带来问题。', '可能会对HDFS客户端造成影响', ''),
        (89, 98, 'dnInfo.getXferPort()获取的是端口信息，不应该作为数组的索引 。', '在使用 NNThroughputBenchmark 验证 blockReport 时，会得到一些异常信息。', ''),
        (90, 99, '在 Checkpointer#doCheckpoint() 中缺少一个必要的写锁', '启用 BackupNode 后，Checkpointer#doCheckpoint() 将开始工作。如果之前没有获得写锁，这时候你会得到一个异常信息，例如：java.lang.AssertionError: Should hold namesystem write lock', ''),
        (91, 101, 'hdfs_allowSnapshot 的源文件使用getopt来解析命令行参数。', 'getopt 仅在 Linux 上可用，因此不是跨平台的。我们需要用boost::program_options替换 getopt来实现这个跨平台。', ''),
        (92, 102, '目前LeaseRenewer（和它的守护线程）在没有客户的情况下应该在一个宽限期后终止，这个宽限期默认为60秒。当LeaseRenewer过期后有新的请求时，可能会发生一个竞赛条件。', 'LeaseRenewer#daemon 线程在 DFSClient 中泄漏，永远无法删除，也没有机会停止', 'HDFS-16235'),
        (93, 103, 'Deadlock in LeaseRenewer for static remove method', '死锁', ''),
        (94, 105, 'HDFS-14547通过本质上实现写时复制策略来节省 EnumCounters 占用的 NameNode 堆空间。一开始，所有 EnumCounters 都引用相同的 ConstEnumCounters 以节省堆空间。当它被修改时，会抛出一个异常，异常处理程序将 ConstEnumCounters 转换为 EnumCounters 对象并更新它。', '使用异常处理程序来执行任何事情，而不是偶尔对性能不利。', 'HDFS-14547'),
        (95, 106, '如果配置中没有设置废弃的httpfs.authentication.signature.secret.file（例如：httpfs-site.xml），那么新的hadoop.http.authentication.signature.secret.file配置选项将不会被使用，它将默默地退回到随机秘密提供者。', '如果这两个配置选项都被设置了，那么HttpFSAuthenticationFilter将以一个不可能的文件路径（例如：${httpfs.config.dir}/httpfs-signature.secret）失败。', ''),
        (96, 107, 'CentOS/RHEL 7 有 glibc 2.17，不支持explicit_bzero。现在我不想放弃对 CentOS/RHEL 7 的支持，我们应该只在它可用时才调用 explicit_bzero。', '该只在它可用时才调用 explicit_bzero', 'HDFS-15910'),
        (97, 108, 'CommandProcessingThread在发生意外错误时，没有捕获异常，也没有退出DN进程', 'DN CommandProcessingThread 退出时客户端无法获取块', ''),
        (98, 109, '在安全模式下，''dfs.block.access.token.enable''应该被设置为''true''。在这种配置下，如果我们进行短路读取时访问令牌过期，SecretManager.InvalidToken异常可能被抛出。这并不重要，因为失败的读取会被重试。', '但它会导致ShortCircuitShm.Slot对象的泄漏。', ''),
        (99, 111, '每次为不存在的 xattr 调用 getXAttrs 时，NN 都会记录完整的堆栈跟踪。日志记录的附加值为零', '增加的日志记录负载可能会损害性能', ''),
        (100, 112, 'libhdfs++ 中的TempDir类目前正在使用由 ftw.h 提供的 nftw API ，该 API 仅存在于 Linux 中，而不存在于 Windows 中', '要使用来自 C++17 std::filesystem的 API来制作这个跨平台。', ''),
        (101, 115, '如果元文件以这种方式被破坏，它的长度在零到小于 7 个字节之间，那么标头是不完整的。在 BlockSender.java 中，逻辑检查元文件长度是否至少为标头的大小，如果不是，则不会出错，而是将 NULL 校验和类型返回给客户端。', '如果客户端收到一个NULL校验和客户端，它根本不会验证校验和，甚至损坏的数据也会返回给阅读器。这意味着这种损坏将被忽视，HDFS 永远不会修复它。即使是卷扫描仪也不会注意到损坏，因为校验和被默默地忽略了。', ''),
        (102, 119, '原因是升级过程在数据节点的每个磁盘卷上添加了一些额外的磁盘存储，因此需要添加一个配置（dfs.datanode.round-robin-volume-choosing-policy.additional-available-space) 在 RoundRobinVolumeChoosingPolicy 中选择卷写入新块数据时保护磁盘空间。', '当我们将我们的 hadoop 集群从 hadoop 2.6.0 升级到 hadoop 3.2.2 时，我们在很多数据节点上遇到了失败的卷，这导致当时丢失了一些块。', ''),
        (103, 122, '当一个块被关闭时，客户端中的数据流等待最终的 ACK 被传递。如果在此等待期间收到异常，则重试关闭。', '不正确的管道关闭恢复会导致永久写入失败或数据丢失。', ''),
        (104, 124, '迭代快照差异报告首先遍历目录差异的创建列表，然后是删除列表。如果删除的列表大小小于创建的列表大小，则相应列表中的偏移量计算似乎是错误的', '因此，差异报告生成调用的下一次迭代，它将开始迭代已创建列表中已处理的内容，从而导致列表中出现重复条目​​', 'HDFS-13252'),
        (105, 125, 'BPOfferService#bpServiceToActive不是易失性的，这可能导致CommandProcessingThread获得过时的活动namenode。当故障转移发生时，旧ANN的CommandProcessingThread可能会读取过时的BPOfferService#bpServiceToActive并执行NN的命令。', '这时，如果新ANN的CommandProcessingThread读到了bpServiceToActive的新值，就会发生脑裂；否则，新ANN的命令不能正常执行，这也是不可接受的。', ''),
        (106, 126, '我们使用LayoutFlags来表示EditLog/FSImage可以支持的特征。该工具帮助将int(0)写入给定的OutputStream，如果EditLog/FSImage支持Layout标志，他们会从InputStream中读取该值以确认是否有不支持的特征标志（非零int）。然而，我们还创建并返回LayoutFlags的新对象，这在任何地方都没有使用，因为它只是一个向/从给定流读/写的工具。', '在使用LayoutFlags#read工具从InputStream读取数据时，我们应该删除这些多余的对象。', ''),
        (107, 127, '在检查HDFS-15146中描述的TestBalancerRPCDelay#testBalancerRPCDelayQpsDefault的间歇性故障时，我发现waitReplication的实现不正确。在最后一次迭代中，当correctReplFactor为false时，线程会休眠1秒，然后抛出一个TimeoutException，而没有检查最后一秒是否完成复制。', 'DFTestUtil.waitReplication 会产生误报', 'HDFS-15671'),
        (108, 128, 'Datanode的关闭是一个非常长的延迟。一个块扫描器在每个VolumeScanner线程上等待5分钟才能加入。由于扫描器是守护线程，不改变区块内容，所以在关闭Datanode时忽略这种情况是安全的。', 'Datanode关闭延迟过长', 'HDFS-9409'),
        (109, 129, '当我们使用WebHdfsFileSystem进行HttpFS时，一些连接在文件系统关闭后会保留一段时间，直到GC运行。', 'WebHdfsFileSystem中存在潜在的连接泄漏', ''),
        (110, 130, 'RpcQueueTime指标在等待服务器状态到达呼叫的客户端状态ID时，每次都会被重新排队更新。这与RpcProcessingTime相反，后者只有在呼叫最终被处理时才会更新。', '在观察者Namenode上，这可能导致RpcQueueTimeNumOps比RpcProcessingTimeNumOps大很多。重新排队是为了避免阻塞而进行的内部优化，不应该导致指标的膨胀。', ''),
        (111, 133, '删除失败的volumes会导致FsDataSetImpl.getBlockReports() NPE', '导致DN停止块汇报', ''),
        (112, 134, '目前ExpiredHeartbeats指标有默认类型，这使得它成为Type.GAUGE。它应该是Type.COUNTER，以便正确绘图。', '绘图失败', ''),
        (113, 135, '问题是数据节点成功向Namenode发送块报告，但Namenode没有正确处理报告，然后HDFS由于丢失块而处于安全模式。', '当使用 HDFS provided storage时（dfs.namenode.provided.enabled=true），有时重新启动Namenode会导致它卡在安全模式。', ''),
        (114, 136, '当平衡器移动一个块时，目标DN块会报告新的位置，并提示使源DN失效。在安全模式下，NN不会发出无效的提示，所以每一个移动的块都显得多余', '数据结构臃肿，大大增加了FULL GC的可能。', ''),
        (115, 138, '由于HDFS-13101中引入的对父目录的isLastReference()检查在某些情况下可能会返回true。', '所以删除快照最终会清理活动fs中的节点，这些节点只能从一个快照中引用', 'HDFS-13101'),
        (116, 139, 'StandbyNode被要求过渡到Active()。如果它在跟踪日志事务中落后太多（来自QJM），它可能会以IllegalStateException崩溃。', 'StanbyNode服务切换到Active状态', ''),
        (117, 140, '泄漏的原因是 StripedBlockChecksumReconstructor 没有关闭 StripedReader。当reader关闭后，CLOSE_WAIT连接就消失了。', '当试图获取EC文件的校验和时，存在一个套接字文件描述符泄漏，', ''),
        (118, 143, '失败的原因是，测试中/user和/append的挂载目标只是URI，没有其他路径。因此，在列举时，为了获取权限，目标URI被用来获取路径，结果是空的。因此失败了', 'TestViewFileSystemOverloadSchemeHdfsFileSystemContract#testListStatusRootDir失败', ''),
        (119, 144, 'EC重构任务失败，processErasureCodingTasks的decrementXmitsInProgress操作异常值。', '这将导致DN的XmitsInProgress为负数，它影响NN根据复制和擦除编码块队列的长度比例来选择待办任务。', ''),
        (120, 145, '编辑加载代码使用了内部调用 `FSDirectory.getINodesInPath()`，它不能完全解析路径。', 'CreateSnapshotOp 在为 /.reserved/raw/path 加载编辑日志期间失败，并出现错误 java.io.FileNotFoundException：目录不存在：/.reserved/raw/path', ''),
        (121, 146, '如果重建任务在StripedBlockChecksumReconstructor上因异常而失败，那么校验和就会变成错误的，因为它是用除了一个失败的块计算的。', '这是由于用不适当的方式捕捉异常造成的。结果，失败的块不会被再次获取。', ''),
        (122, 147, '通常在每 1M 块的数据节点上使用 1GB 堆的规则。对于有很多块的节点，这可能意味着很多堆。', 'Datanode DirectoryScanner 使用过多的内存', ''),
        (123, 149, 'Check whether file is being truncated should before truncate', 'truncate不一定会完成', ''),
        (124, 151, '当删除卷时，我们需要使卷中的所有块失效。在下面的代码中（FsDatasetImpl），我们在blkToInvalidate地图中保留了将被废止的块。然而，由于该地图的关键是bpid（块池ID），它将被其他被删除的卷覆盖。', '删除多个 DN 的数据目录后，DN 中不断发生 ReplicaNotFoundException', ''),
        (125, 152, 'FSEditLogAsync创建了一个FSEditLogOp，并在FSNamesystem.writeLock内填充其字段。但是有一个重要的字段，即编辑操作的交易ID，在操作被安排为同步的时候，仍然没有设置。那时，beginTransaction()将设置FSEditLogOp.txid并增加全局事务计数。在繁忙的NameNode上，这个事件可能落在写锁之外。', '这给观察者的读取带来了问题。它也有可能重新洗牌交易，而Standby会以错误的顺序应用它们。', 'HDFS-16050'),
        (126, 153, 'LowRedundancyBlocks.java中的函数“remove”不会从所有队列中删除块。', '导致损坏的块与 NN Web UI 上的损坏文件不匹配。', ''),
        (127, 154, 'hdfs-default.xml 中对 dfs.namenode.replication.max-streams 的描述具有误导性。', '修改文档描述', ''),
        (128, 155, '客户端向名称节点发送“完成”调用，将块移动到已提交状态，但它在将最终数据包发送到数据节点告诉它们完成块之前就死了。', '这意味着块被卡在 RBW 状态的数据节点上，并且没有任何东西会告诉它们移出该状态。', ''),
        (129, 157, '被删除的区块被遗留在复制队列中', '在通过重启两个死节点解决了丢失区块的事件后，仍有8个区块丢失，但列表中是空的。Metasave显示这8个区块是 orphaned，意味着这些文件已经被删除', ''),
        (130, 159, '当 createWriter() 发生异常并且 0 < nSuccess < targets.length 时发生 NPE。 ', 'StripedWriter.clearBuffers 在EC重构块期间导致 NPE', ''),
        (131, 160, '在故障转移后，NameNode 抱怨文件损坏/丢失块。这些块在完整的块报告后确实恢复了，因此这些块实际上并没有丢失。', '在的编辑日志竞争条件可能导致文件损坏', ''),
        (132, 162, '当 NameNode 变为 UNAVAILABLE 时，dfsrouter 上 MembershipStoreImpl#activeNamespaces 中相应的块池 id 会无意中设置为空，即其初始值', '通过 dfsrouter 的 concat 操作失败', ''),
        (133, 163, 'testHDFSConf.xml uses regexes [a-zA-z0-9]*', 'TestHDFSCLI fails for user names with the dot/dash character', 'HDFS-5821'),
        (134, 164, '配置参数“dfs.mover.retry.max.attempts”是定义mover认为移动失败之前的最大重试次数。没有检查代码，因此此参数可以接受任何 int 值。', '从理论上讲，将这个值设置为<=0应该意味着根本没有重试。然而，如果你把这个值设置为负值。重试失败的检查条件将永远不会满足，因为if语句是if (retryCount.get() == retryMaxAttempts)。重试次数在失败后总是通过retryCount.incrementAndGet()来增加，但永远不会=retryMaxAttempts。', ''),
        (135, 165, '代码逻辑问题', 'LeaseManager 在创建失败的文件上永远循环，打出过多无限重复的日志', ''),
        (136, 166, '如果 dfs.client.use.datanode.hostname 为true，那么它将尝试通过主机名连接。如果无法解析主机名，则会从 `newConnectedPeer` 抛出 UnresolvedAddressException。', 'UnresolvedAddressException 不是 IOException 的子类，所以 `nextTcpPeer` 根本不处理这个异常。这个未处理的异常可能会使系统崩溃。', ''),
        (137, 168, '因为while循环条件 item.getErrorCount() < getMaxError(item) 无法满足值为0的情况', '在HDFS磁盘平衡器中，配置参数 dfs.disk.balancer.max.disk.errors 是用来控制两个磁盘之间的特定移动在被放弃之前我们可以忽略的最大错误数的值。该参数可以接受>=0的值。而将该值设置为0应该意味着没有错误容忍。然而，设置该值为0将简单地不做块复制，即使没有磁盘错误发生，', ''),
        (138, 169, '新的 API 引入 getSnapshotDiffReportListing 破坏了向后兼容性', '当在从 hadoop 3 集群到 hadoop 2 集群的两个快照之间使用 distcp 差异选项时抛出异常', 'HIVE-24852'),
        (139, 170, 'Some dynamometer tests fail', '一些测试集测试失败', ''),
        (140, 171, '代码逻辑问题', 'Hadoop 3.2.0客户端执行以下命令：hdfs dfsadmin -Dfs.defaultFS=hdfs://xxx -listOpenFiles -blockingDecommission -path /xxx,偶尔抛出NPE', ''),
        (141, 172, 'TestBalanceProcedureScheduler 和 TestDistCpProcedure 超时', '测试超时', ''),
        (142, 173, '代码逻辑问题', 'the internal block is replicated many times when datanode is decommissioning', ''),
        (143, 174, ' getCompressedAliasMap中可能存在资源泄漏。如果 第 334 行的finish()抛出 IOException，则tOut、gzOut和bOut保持打开状态，因为该异常没有在本地捕获，并且任何调用者都无法关闭它们。', '资源泄露', ''),
        (144, 175, '如果前一个令牌过期，WebHdfsFileSystem 将捕获异常并尝试获取新令牌。但是，获取新令牌的机制绕过了在 UGI 上搜索令牌，因此即使有外部逻辑已检索到新令牌，也不可能使 FileSystem 使用新的有效令牌，从而呈现 FileSystem 对象无法使用。', '呈现 FileSystem 对象无法使用', ''),
        (145, 176, '因为hadoop3增加了新的PROVIDED存储类型', '当nn升级到3.1.3，dn的版本还是2.6时，我们发现hive调用getContentSummary方法，客户端和服务器不兼容', 'HDFS-9806'),
        (146, 177, '在HDFS-13617, NameNode 可以配置为将其建立的 QOP 作为加密消息包装到块访问令牌中。稍后 DataNode 将使用此消息创建 SASL 连接。但是这个新行为应该只适用于新的辅助 NameNode 端口，而不是主端口（在 fs.defaultFS 中配置的那个）', '因为它可能会导致与现有的其他 SASL 相关配置（例如 dfs.data.transfer.protection）发生冲突的行为。由于此配置仅针对辅助端口引入，因此我们应将此新行为限制为不适用于主端口。', ''),
        (147, 179, 'DeepCopyReplica方法从ReplicaMap中获取FoldedTreeSet<ReplicaInfo>，同时FoldedTreeSet<ReplicaInfo>可能因addblock或removeblock而改变。此时 ConcurrentModificationException 出现。', 'ReplicaCachingGetSpaceUsed 抛出 ConcurrentModificationException', ''),
        (148, 180, 'RBFMetrics 中使用 Long 类型字段 TotalCapacity、UsedCapacity 和 RemainingCapacity', 'Long类型字段可能超出范围。', ''),
        (149, 182, 'HDFS-15025 添加新的存储类型 NVDIMM，更改 StorageType 枚举的 ordinal()。并且，通过 storageType 设置配额依赖于 ordinal()，因此升级后可能会导致配额设置无效。', 'the setting of quota to be invalid after upgrade.', 'HDFS-15025'),
        (150, 183, '单击路由器 UI 上的 Datanodes 标记没有响应。', '无法显示路由器的数据节点 UI', ''),
        (151, 184, '在 RouterWebHdfsMethods 中，对于 CREATE 调用，chooseDatanode 首先通过 getDatanodeReport 获得所有 DN，然后通过 getRandomDatanode 从列表中随机挑选一个', '这个逻辑似乎并不正确，因为它应该为输入路径的特定群集挑选一个 DN。', ''),
        (152, 185, 'HDFS-8983添加了fs.protected.directories来支持NameNode上的受保护目录。但是当把一个父目录（如/testA）设置为受保护目录时，子目录（如/testA/testB）仍然可以被删除或重命名', '当我们保护一个目录时，主要是为了保护这个目录下的数据，所以如果父目录是受保护的目录，子目录不应该被删除或重命名。', 'HDFS-8983'),
        (153, 188, 'On truncate and append we remove the blocks from Reconstruction Queue.On removing the blocks from pending reconstruction , we need to decrement Blocks Scheduled', 'Blocks scheduled count was wrong on truncate', ''),
        (154, 189, '如果删除目录不成功，我们仍然可以 成功从快照表中删除目录  ', '这是的系统数据不一致', ''),
        (155, 190, 'HttpFS：setWorkingDirectory 不应接受无效路径', 'HttpFS：setWorkingDirectory 不应接受无效路径', ''),
        (156, 191, '路由器挂载的路径在NN上不存在，路由器会创建挂载名称的虚拟文件夹。', '但是http上的“浏览文件syaytem”显示是错误的。', ''),
        (157, 192, '当 RPC 地址为 IP 时，updateActiveNamenode() 无效', '当 RPC 地址为 IP 时，updateActiveNamenode() 无效', ''),
        (158, 193, '在问题HDFS-13443中，立即更新挂载表缓存。指定的路由器会立即更新自己的挂载表缓存，然后通过rpc协议refreshMountTableEntries更新其他路由器的缓存。但在安全模式下，不能更新其他路由器的。', '抛出异常，无法更新其他路由器的缓存。', 'HDFS-13443'),
        (159, 194, '验证 HttpFSUtils 中的内容类型是否为 JSON。', '新增一个验证', ''),
        (160, 196, '代码逻辑问题', '审计日志记录了调用删除时的意外允许结果', ''),
        (161, 197, '关于计算空间配额使用量,我们漏掉了文件快照功能中的Diffs块。', 'Quota Space consumed was wrong in truncate with Snapshots', ''),
        (162, 198, '在目录“dir1”中创建了一个文件“file1”并创建了 dir1 的快照，将 dir1 中的 file1 移动到“/”（rootDir）现在在对“/file1”进行截断时，它正在修改也存在快照的文件的内容。因此，在获取快照中存在的 file1 时，我得到了 ArrayIndexofBoundsException ，因为文件大小（即块大小）由于截断而被修改，但 filediff 没有修改', 'BlockManager CreateLocatedBlock 中的 ArrayIndexOfboundsException', ''),
        (163, 199, 'TestReplicaCachingGetSpaceUsed #testReplicaCachingGetSpaceUsedByRBWReplica 在 Windows 上失败，因为当 RBW 应重命名为 Finalized 时，Windows 不支持 .', '这应该在 Windows 上跳过 ', ''),
        (164, 200, '默认值 dfs.image.transfer.bandwidthPerSec 设置为 0，因此它可以在检查点期间将最大可用带宽用于 fsimage 传输。', '应该限制这个。在 dfs.namenode.name.dir 上传输大图像以及 fsimage 复制时，许多用户都经历了 namenode 故障转移。', ''),
        (165, 205, '需要通过引用捕获多态异常类型以实现多态使用，如果有的话。否则，被捕获对象的功能仅限于基类的功能。', '当前已按值捕获，因此会报告以下警告 warning: catching polymorphic type ''struct hdfs::ha_parse_error'' by value [-Wcatch-value=]', ''),
        (166, 206, '复制的字符串故意不以 null 结尾，因此我们适当地附加了一个自定义字符。strncpy 报告的警告有效，但不适用于此场景。因此，我们需要使用 memcpy，它不介意字符串是否为空终止。', '编译 HDFS 本​​机客户端时收到警告 warning: ''__builtin_strncpy'' output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]', 'HDFS-15922'),
        (167, 207, '复制的字符串故意不以 null 结尾，因为我们想自己插入一个 PATH_SEPARATOR。strncpy 报告的警告有效，但不适用于此场景。因此，我们需要使用 memcpy，它不介意字符串是否为空终止。', '编译 HDFS 本​​机客户端时收到警告 warning: ''__builtin_strncpy'' output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]', 'HDFS-15935'),
        (168, 208, 'Datanode由于负载太高而被排除在外，因此无法写入最后一个块。', 'TestExternalStoragePolicySatisfier 间歇性超时失败', ''),
        (169, 209, '所有文档都参考了默认的块放置策略但是，随着时间的推移，出现了新的策略：BlockPlacementPolicyRackFaultTolerant (HDFS-7891)、BlockPlacementPolicyWithNodeGroup (HDFS-3601)、BlockPlacementPolicyWithUpgradeDomain (HDFS-9006)', '应该更新文档以引用它们来解释它们的特殊性以及可能如何设置它们中的每一个', 'DHFS-7891、HDFS-3601、HDFS-9006'),
        (170, 210, 'dfs.datanode.block.id.layout.upgrade.threads，默认为每个磁盘 12 个线程', 'hardlink thread线程数太多，造成运行时缓慢', ''),
        (171, 211, 'RouterWebHdfsMethods.java中的 REMOTE_ADDRESS 是一个ThreadLocal字段，在构造方法RouterWebHdfsMethods（）和init（）中设置。当我们调用方法Server.getRemoteIp()来获取远程IP时，线程将被改变，所以ThreadLocal字段 REMOTE_ADDRESS 为空，并将通过InetAddress.getByName()传递给 localhost/127.0.0.1', '通过Server.getRemoteIp()获取远程ip，但结果为错误的 localhost/127.0.0.1', ''),
        (172, 212, 'HttpFS：使用 noredirect 的 Create 响应不正确且数据为 true', '响应错误', ''),
        (173, 213, 'checksInProgress和completedChecks分别是非线程安全的 HashMap 和 WeakHashMap。', 'ThrottledAsyncChecker 不是线程安全的,以致于当有多个命名空间时，它无法被多个线程使用', ''),
        (174, 214, 'hadoop-hdfs-native-client的-Pdist build失败', '构建失败', ''),
        (175, 215, '代码中调用 close on storage可能会引发异常。如果发生了，committedTxnId和curSegment永远不会关闭。', '资源泄露', ''),
        (176, 216, '代码中发生 I/O 错误，则 rp 保持打开状态，因为没有在本地捕获异常，并且任何调用者都无法关闭 RandomAccessFile。', '资源泄露', ''),
        (177, 217, 'DeadNodeDetector 不会从死节点集中删除活动节点', '进入死循环，无法恢复活节点', 'HDFS-13571'),
        (178, 218, 'DeadNodeDetector 关闭时不会关闭所有线程。', 'DeadNodeDetector 应在关闭时关闭所有线程。', ''),
        (179, 219, '代码中发生 I/O 错误，则fin保持打开状态，因为未在本地捕获异常，并且任何调用者都无法关闭 FileInputStream', '资源泄露', ''),
        (180, 220, '目前 DeadNodeDetector 是 ClientContext 的成员。这意味着它由许多不同的 DFSClients 共享。', '当调用一个 DFSClient.close() 时，DeadNodeDetecotor 线程将被中断并影响其他 DFSClients。', 'HDFS-13571'),
        (181, 221, '原因是在ClientNamenodeServerSideTranslatorPb使用 else if 设置了标志', '当指定重命名覆盖标志时，To_TRASH 选项会被静默忽略。', ''),
        (182, 222, '配置参数 dfs.datanode.max.transfer.threads 是指定用于将数据传入和传出 DN 的最大线程数。该参数十分重要，当被设置为非常小的值的时候会出现奇怪的失败', '应该为它添加检查代码，以防止用户不小心将值设置为不合理的值', ''),
        (183, 223, '并发异常问题', '加载 FSImage 时出现 ClasscastException', 'HDFS-15907、HDFS-14617'),
        (184, 224, '无法在路由器客户端上获取方法 setBalancerBandwidth', '调用 setBalancerBandwidth 时，抛出异常。', ''),
        (185, 226, 'blockFromXml方法需要一个块对象，但传递了一个数据对象', '存在 OP_TRUNCATE 时 HDFS OEV 反序列化编辑日志从 XML 转换为二进制错误', ''),
        (186, 227, '字符串表不兼容', '从 3.2.0 降级到 2.7 失败', ''),
        (187, 228, 'ZKFC 改变 Observer Namenode 状态为 Standby', 'TestDFSZKFailoverController 一直失败，在 testManualFailoverWithDFSHAAdmin() 中等待超时', 'HDFS-14130、HDFS-15023、HDFS-14998'),
        (188, 229, 'DFSTestUtil#addDataNodeLayoutVersion 使用反射来更新最终变量，但是在 Java 12+ 中是不允许的', 'DFSTestUtil#addDataNodeLayoutVersion 失败', ''),
        (189, 230, 'TestWebHDFS.testLargeDirectory 失败', '测试失败', ''),
        (190, 231, '错误发生在解析令牌时第一次调用readVlong时。这两个 Jiras 只会改变块令牌尾部的行为', 'HDFS客户端应用程序从从 3.2.0 升级到了 3.2.1，升级之后与仍运行Hadoop 2.x的集群一起使用，会出现EOF错误', ''),
        (191, 232, '当启用容错的随机挂载点的子集群不可用时，写入应该允许。', '如果一个子集群关闭并且启用了容错，则 RANDOM 挂载点应该允许创建新文件。但在这里失败了', ''),
        (192, 233, 'Cluster is HA with 2 namenodes(0, 1) and client may access 1 namenode( standby). but UT metric is from index 0. So It''s flaky', 'estNameNodeRetryCacheMetrics 间歇性失败', ''),
        (193, 234, 'FSCK应该去尝试其他Namenode，忽略不可用的Namenode，而不是直接失败', '当一个Namenode不可用的时候，FSCK失败', ''),
        (194, 235, 'proxy-handling 代码在不同的方法中存在差异', 'HAUtil.getAddressOfActive 和 RpcInvocationHandler.getConnectionId 不一致', ''),
        (195, 236, 'The test is failing due to addition of a new storage type NVDIMM in middle.', 'TestRouterQuota fails in trunk', 'HDFS-15025'),
        (196, 237, 'TestSnapshotCommands.testMaxSnapshotLimit 在trunk中失败', '测试失败', ''),
        (197, 238, '当 dfs.namenode.safemode.min.datanodes 不为零时，防止对代价高昂的操作 getNumLiveDataNodes 进行不必要的评估', '每个块的 getNumLiveDataNodes 调用会引起性能问题', 'HDFS-14171、HDFS-14623'),
        (198, 240, '目前删除快照不更新修改时间', '在创建快照时，我们设置了快照的修改时间，同时我们更新了快照创建目录的修改时间', ''),
        (199, 241, '目前重命名快照不更新修改时间', '应该修改时间', ''),
        (200, 242, '快照修改时间在名称节点重新启动时会更改', '应该防止防止快照修改时间在启动时发生变化', ''),
        (201, 243, '测试失败', 'TestHDFSContractMultipartUploader在主干上失败并出现IllegalArgumentException', 'HDFS-13934、HADOOP-17233'),
        (202, 244, 'NameNode 启动时首先启动 HttpServer，然后开始加载 fsImage 并进行编辑。加载 NameNode 中的名称系统字段时为空。我看到一个 StandbyNode 发送一个检查点请求，由于 NNStorage 尚未实例化，因此 NPE 失败。', 'NameNode启动期间HttpServer NPE异常', ''),
        (203, 245, '“移至垃圾箱”在 FSNameSystem 和 FSDirRenameOp 中使用了不同的重命名方法', '受保护的目录仍然可以移动到垃圾箱', 'HDFS-8983、HDFS-14802、HDFS-15243'),
        (204, 246, '使用快照重命名不遵守配额限制', '使用快照重命名不遵守配额限制', ''),
        (205, 247, '目前，在调用createSnapshot和getSnapshotListing后，命名空间路径被替换为mount路径。', '这就假定调用的位置总是序列中的第一个，但有多种原因，目录可能不在第一个位置上。所以，我们不应该使用firstLocation来替换，而应该使用实际调用的位置来替换路径。', ''),
        (206, 248, '当向 DomainPeer 请求文件描述符时，我们为 BufferedOutputStream 分配了巨大的 8KB 缓冲区，尽管协议内容很小，只有几个字节', 'requestFileDescriptors#BufferedOutputStream中默认的8KB缓冲区在HBase中使用短循环读取时导致大量的堆分配。', 'HBASE-22387、HBASE-21879'),
        (207, 251, '无法从 WebUI 修改文件和目录权限', '无法从 WebUI 修改文件和目录权限', ''),
        (208, 252, '从3.0.0开始 fsck 不再显示进度（每个文件打印一个点），如果集群很大，可能会发生超时', '执行命令 ''hdfs fsck /'' 来检查集群的健康状态时，会出现SocketTimeoutException', ''),
        (209, 254, '在像“mvn package -Pnative”这样的 Hadoop 构建中，会将 HDFS 本​​机库复制到 target/lib/native。目前它只会复制 C 客户端库（libhdfs.{a,so}）。那里缺少基于 C++ 的 HDFS 客户端库（libhdfspp.{a,so}）。', 'dist 包中缺少 libhdfspp 库', ''),
        (210, 256, 'isInLatestSnapshot() 可能在 inode 的祖先可能不在最新快照中的情况下返回 true。', '逻辑错误', ''),
        (211, 257, '从备用 NameNode 到 Active 的图像传输在 Active 上静默失败，没有任何日志记录，也没有通知接收方。', '活动 NameNode 不应默默地使图像传输失败', ''),
        (212, 258, 'hdfs 加密命令需要限制列宽', '当路径很长时，该命令最终看起来非常难看。这也使得将输出通过管道传输到其他实用程序（例如 awk）变得非常困难。', ''),
        (213, 259, 'IPCLoggerChannel#createParallelExecutor 中的线程数现在是弹性的', '目前corePoolSize设置为 1 并且maximumPoolSize设置为numThread，但是由于 Queue 的大小是Integer.MAX，队列不会变满并且线程总是被限制为 1 而不管numThreads', ''),
        (214, 261, '应该使用 .test 而不是 .com 进行测试', 'TestConfiguredFailoverProxyProvider.testResolveDomainNameUsingDNS 失败。', ''),
        (215, 262, '代码逻辑问题', '使用 NULL 校验和时无法使用 ArithmeticException 启动 DN', ''),
        (216, 263, 'INodeAttributeProvider 的新 API checkPermissionWithContext 没有被调用以进行授权', 'API没有被使用', ''),
        (217, 264, '没有捕获处理相关异常', 'Namenode 启动安全模式 加载fsimage期间，通过REST API访问Namenode时，抛出NPE', ''),
        (218, 265, '由于更改了 CallQueue 构造函数，TestRefreshCallQueue 失败', 'TestRefreshCallQueue.MockCallQueue无法实例化，因为它在构造函数中缺少一个参数', 'HDFS-15324、HADOOP-17010、HDFS-10253'),
        (219, 266, '代码逻辑问题', '当对“http://<DN host>:<DN port>/”的请求不带“webhdfs/v1”后缀时，DN返回500响应码并抛出StringIndexOutOfBoundsException', 'HDFS-14234'),
        (220, 267, 'HDFS-14651的变化经常导致TestDeadNodeDetection的超时。在JUnit中涉及到许多配置和线程，但等待时间非常长，为100秒，在连续调用WaitFor时最终超时了。', 'TestDeadNodeDetection JUnit 超时超时', 'hdfs-14654、HDFS-13571'),
        (221, 268, '代码逻辑问题', '考虑DataNode负载时，相同的距离和负载节点不会shuffle', 'HDFS-14882'),
        (222, 269, 'invokeMethod 函数的参数传递不正确。', 'hdfs-fuse 中的 statfs 功能不起作用', ''),
        (223, 270, '修复 HDFS-15217 中引入的 findbugs 警告', '修复 HDFS-15217 中引入的 findbugs 警告', 'HDFS-15217'),
        (224, 271, '两个块都从磁盘中成功删除，但是 BlockReport 是从内存中的数据发送的，InMemory 数据由DirectoryScanner更正目录扫描程序线程与测试并行运行，因此只有一个块可以被标记为删除，另一个块仍然被报告。        ', 'TestNNHandlesBlockReportPerStorage::blockReport_02 in trunk 间歇性失败', ''),
        (225, 272, '服务 RPC 端口专用于 DataNode 通过块报告和心跳报告其状态，也用于 ZKFC 定期检查 NN 健康。它不是面向客户端应用程序的。NN 的服务 RPC 绑定主机（如果提供）也应该受到 ZKFC 的尊重。回退仍然是 rpc 绑定地址。', '如果配置了’dfs.namenode.servicerpc-bind-host‘，ZKFC会将主机地址绑定到此，否则会被绑定到’dfs.namenode.rpc-bind-host‘，若果二者都没有配置ZKFC将自己绑定到NameNode RPC服务器地址：’dfs.namenode.rpc-address‘', ''),
        (226, 273, 'MountTableRefresherService 在安全模式下刷新其他路由器 MountTableEntries 失败。', '无法刷新路由器挂载表条目缓存', ''),
        (227, 274, 'DN 会对路径进行双重解码', '百分比 (%) 和加号 (+) 字符在 WebHDFS 中不再起作用', ''),
        (228, 275, '缓存池“getMaxRelativeExpiryMs”永远不会持久保存到 FSImage 或从 FSImage 读取', '意味着如果在池上设置了 MAXTTL，它将不会在集群重新启动后持续存在', ''),
        (229, 277, '当 ResponseProcessor.run 抛出错误时，DFS 客户端将卡住', '一个 Tez 应用程序在我们杀死这个应用程序之前停留了 2 个多小时。原因是任务尝试被卡住，因为speculative execution被禁用', ''),
        (230, 278, 'HDFS-12130改变了 DU 命令的行为。它将检查权限和计算合并到一个步骤中。在此更改期间，当需要 getInodeAttributes 时，它只是使用 inode.getAttributes()。但是当配置了属性提供者类时，我们应该调用属性提供者配置的对象来获取 InodeAttributes 并在 checkPermission 期间使用返回的 InodeAttributes。 ', '当 du 命令针对 Sentry 管理的 hdfs 路径运行时，会导致了 AccessControlException 的问题', 'HDFS-12130'),
        (231, 279, '如果作用域为 d1 且排除作用域为 d10，则作用域仍将从排除作用域开始，因此按当前逻辑它将返回 null，它应该附加分隔符然后检查。', '逻辑错误，应该修改逻辑', ''),
        (232, 280, 'AvailableSpaceBlockPlacementPolicy 类扩展了 BlockPlacementPolicyDefault。但是它并没有改变在 BlockPlacementPolicyDefault 中选择第一个节点的行为，所以即使有了这个新特性，本地 DN 总是被选为第一个 DN（当然当它没有被排除时），并且新特性只改变了选择其余两个 DN', 'AvailableSpaceBlockPlacementPolicy 总是首选本地节点', ''),
        (233, 281, 'MaxSnapshotID 上限是 16777215，SNAPSHOT_ID_BIT_WIDTH有些太低了。', '无法拍摄 HDFS 快照，并且 snapshotCounter 达到 MaxSnapshotID 限制', ''),
        (234, 282, '代码逻辑问题', 'QuotaUsage 和 ContentSummary 中消耗的 INodeReference 空间不同', 'HDFS-14499、HDFS-8327'),
        (235, 283, 'Provide Non DFS Used per DataNode in DataNode UI', '提供该功能', ''),
        (236, 284, '时间戳来自 System.nanoTime(),只能用于测量经过的事件，需要从 System.currentTimeMillis() 制作时间戳。 ', '最长写/读锁持有日志的时间戳错误', ''),
        (237, 285, '根本原因是 addStoredBlock 没有考虑复制处于 Decommission 的情况', '某些情况下，Block 将保持 COMMITTED but not COMPLETE 状态，无法正常关闭', ''),
        (238, 286, '使用 GCC 7 修复 libhdfspp 测试失败', '测试失败', ''),
        (239, 287, '如果 dfs.namenode.file.close.num-committed-allowed 为 1，因此即使块处于已提交状态（未完成），它也允许关闭文件。NPE 在非常罕见的情况下发生：', '当 hdfs 中存在超过 200 万个块并且正在写入某些块时，''hdfs fsck / -files -blocks -upgradedomains''失败', ''),
        (240, 288, 'WebHDFS：将快照计数添加到内容摘要', 'WebHDFS：将快照计数添加到内容摘要', ''),
        (241, 289, '在设置 Xattrs 时添加健全性检查以确保zone key 等于 feinfo key', '新增一个检查', ''),
        (242, 290, 'BlockReaderRemote#newBlockReader#BufferedOutputStream 默认的 8KB 缓冲区太大', '将 DFSClient 远程读取的输出流缓冲区大小从 8KB 减少到 512 字节。', ''),
        (243, 291, '在DataNodeVolumeMetrics中使用了一些不正确的对象，writeIoRate从未被使用', '在有些代码中，syncIoRate应该被writeIoRate取代。', ''),
        (244, 292, '-showprogress已弃用', '但在fsck -help显示的用法中仍旧有-showprogress参数', 'HDFS-7175'),
        (245, 293, '在org.apache.hadoop.hdfs.server.blockmanagement.handleHeartbeat中，当slowDisks总是空的时候，SlowDiskReport不会更新', '这可能导致过时的SlowDiskReport总是留在namenode的jmx中，直到下次slowDisks不空', ''),
        (246, 294, 'EC:BlockRecoveryWorker#RecoveryTaskStriped 中的 ArrayIndexOutOfBoundsException', '抛出异常未处理', ''),
        (247, 295, 'TestEncryptionZones.testVersionAndSuiteNegotiation 在trunk中失败', '失败', 'HADOOP-16885'),
        (248, 296, 'TestRetryCacheWithHA testRemoveCacheDescriptor 间歇性失败', '间歇性失败', ''),
        (249, 297, 'Quota Usage and Content summary are not same in Truncate with Snapshot', '显示不同', ''),
        (250, 298, '试图将Observer过渡到Standy状态，stopStandbyServices()记录它是''Stopping services started for standby state''，但应该是’Stopping services started for observer state‘ ', '让日志更合理', ''),
        (251, 299, 'BlockSender 中的 NPE', 'BlockSender 中的 NPE', ''),
        (252, 300, '删除 ByteStringLog 中的冗余字段 fStream', '删除 ByteStringLog 中的冗余字段 fStream', ''),
        (253, 301, '在LOAD_EDITS阶段完成后，Startup Progress页面继续报告编辑段。新的步骤被添加到StartupProgress中，同时期刊尾随，直到所有启动阶段都完成。这增加了大量的编辑步骤，因为SAFEMODE阶段在一个大型集群上可能需要很长的时间。', '在快速尾随的情况下，片段很小，但数量却很大--160K。这使得页面永远加载。', ''),
        (254, 302, 'WebHDFS getTrashRoot 由于创建 FileSystem 对象而导致 OOM', 'NN 不应该为自己创建文件系统，并且绝不能在远程用户的上下文中创建文件系统，否则缓存会爆炸', 'HDFS-10756'),
        (255, 303, 'NameNode StartupProgress 在 LOADING_EDITS 阶段完成后继续报告编辑日志段', '该逻辑调用时机错误', ''),
        (256, 304, ' StringBuilder 构建器 将在 BlockPlacementPolicyDefault.chooseRandom 方法中使用 4 次。而构建器仅在此方法的第一次初始化。如果我们将 BlockPlacementPolicyDefault 的 logger 更改为在该部分之后进行调试，则 剩余部分的builder为NULL并导致NPE', '动态更改记录器以调试时，BlockPlacementPolicyDefault 中的 NPE 导致 Namenode 崩溃', ''),
        (257, 305, '由于HDFS-15099返回 RetryOnActiveException，导致错误消息发生变化，并且测试是在日志捕获上断言，因此它得到了不同的消息并且断言​​失败', 'TestDelegationTokensWithHA断言失败', ''),
        (258, 306, '当evictableMmapped或evictable size为0时，不要在ShortCircuitCache#close()中抛出NoSuchElementException。', '当evictableMmapped或evictable size为0时，不要在ShortCircuitCache#close()中抛出NoSuchElementException。', 'HDFS-14541'),
        (259, 307, '当 evictableMmapped 或 evictable 大小为零时，不应该抛出 NoSuchElementException', '该try catch有严重的性能问题', ''),
        (260, 309, '当请求标头中未设置 Cookie 时，安全模式下的 LOG 泛滥', '异常堆栈被重复,且没有任何意义', ''),
        (261, 310, '现有代码使用assertTrue(),但应该使用assertEquals()', 'getAclStatus 始终将权限返回为 null', ''),
        (262, 311, '函数 checkDiskError() 在 addBlockPool 之前被调用，但这次 bpSlices 列表为空。所以 FsVolumeImpl.java 中的函数 check() 什么都不做。', '在datanode启动期间checkDiskError不起作用', ''),
        (263, 312, 'BlockPlacementPolicy具有getPolicy方法，该方法根据块类型返回。', 'LocationStripedBlock 返回块类型为 CONTIGUOUS ，实际上应该是STRIPED', ''),
        (264, 315, '如果发生故障，namenodeResolver.updateActiveNamenode(nsId, address);会被调用，但这并不会使缓存失效，所以下一次会获取正确的active。', 'MembershipNamenodeResolver 应该在活动名称节点更新的情况下使缓存无效', ''),
        (265, 316, '执行getBlockLocations()时更新 INode 的 aTime 的精度默认为 1 小时。ObserverNode 无法处理更新，因此应将调用重定向到 Active NameNode。为了重定向到活动的 ObserverNode 应该通过ObserverRetryOnActiveException。', 'checkOperation(WRITE) 应该在 ObserverNode 上抛出 ObserverRetryOnActiveException', ''),
        (266, 317, 'testDecommissionStatus是不稳定的，在HDFS-14854修复，但该修复代码被意外注释掉了', '应该恢复注释代码', 'HDFS-14858'),
        (267, 318, '不支持 HttpFS 中路径为“/”的 POST 请求。', '不支持 HttpFS 中路径为“/”的 POST 请求。', ''),
        (268, 319, '不支持路径为“/”的 HttpFS 中的 PUT 请求。', '不支持路径为“/”的 HttpFS 中的 PUT 请求。', ''),
        (269, 320, '某些应用程序可以读取指定偏移量的 pmem 缓存段。先前使用 DirectByteBuffer 读取 pmem 缓存的实现没有涵盖这种情况', '出现读取带偏移量的持久内存缓存数据的问题', ''),
        (270, 321, '前对 HttpFS 的 LISTSTATUS 调用返回一个 json。这些 jsonArray 元素具有 ecPolicy 名称。但是当 HttpFsFileSystem 将其转换回 FileStatus 对象时，则不添加 ecPolicy', 'HttpFS：getFileStatus 不返回 ecPolicy', ''),
        (271, 322, '使用了具有afterExecute方法的HadoopThreadPoolExecutor', '当 dfs.ha.tail-edits.period 为 0 时，备用 NN 抛出许多 InterruptedExceptions', ''),
        (272, 323, '三个测试TestGetBlockLocations、TestFSNamesystem、TestDiskspaceQuotaUpdate使用FSDirectory方法，这些方法持有 FSDirectory 锁。他们还应该持有全局 Namesystem 锁。', '修复持有 FSDirectory 锁的测试，而不持有 FSNamesystem 锁。 ', ''),
        (273, 324, 'concat操作后namequota没有更新', 'namequota错误', ''),
        (274, 325, 'Balancer 无法通过 ObserverReadProxyProvider 联系不可用的 NN 时崩溃', 'Balancer崩溃', 'HDFS-14162、hdfs-14979'),
        (275, 326, '目前log in info', 'DataStreamer#createBlockOutputStream() should log exception in warn.', ''),
        (276, 327, 'HDFS-14835是一个类似的修复程序，它检查 SecreatManager 是否为空。但它没有涵盖这个案例。所以我们还需要检查运行状态。', '当 SecretManager 未运行时，安全路由器也在运行。它不应该运行。', 'HDFS-14835'),
        (277, 329, '在HDFS-11384，添加了一种机制，使 Balancer/Mover 发出的getBlocks RPC 调用更加分散，以减轻 NameNode 上的负载，因为getBlocks可能非常昂贵，并且 Balancer 不应该影响正常的集群操作。不幸的是，该功能无法按与其运行。', 'Balancer getBlocks RPC dispersal does not function properly', 'HDFS-11384'),
        (278, 330, '冗余导入', '应该删除 NameNodeConnector 中 AtomicBoolean 的冗余导入。', ''),
        (279, 331, 'BlockPoolSlice#initializeAddReplicaPool()方法当前初始化静态线程池实例。但是当两个BPServiceActor Actor 尝试并行加载块池时，它可能会创建不同的实例。', 'BlockPoolSlice#initializeAddReplicaPool()方法应该是一个静态方法。', ''),
        (280, 332, 'startsWith() 错误', 'FSCK -list-corruptfileblocks 返回无效条目', ''),
        (281, 333, 'TestOfflineEditsViewer 在 Trunk 中失败', '测试失败', 'HDFS-14922、HDFS-14924'),
        (282, 334, '代码逻辑问题', '在多个目的地的情况下，设置了 EC 策略的目录的 GetFileStatus 失败', ''),
        (283, 335, '在 TestWebHDFS 测试类中，很少有测试用例没有关闭 MiniDFSCluster，这导致 Windows 中剩余的测试失败。一旦集群状态打开，所有连续的测试用例都无法获得对 Data dir 的锁定，从而导致测试用例失败。', 'TestWebHDFS 在 Windows 中失败', ''),
        (284, 336, '现在我们可以设置 fs.protected.directories 来防止用户删除重要目录。但是用户可以删除限制周围的目录。1.重命名目录并删除它们。2. 将目录移至垃圾箱，namenode 将删除它们。', 'The feature of protect directories should be used in RenameOp', ''),
        (285, 337, '如果block长度为Long.MAX_VALUE，则表示属于该block的文件从namenode中删除，DN得到删除文件后的命令。在这种情况下，应该忽略命令。', '错误逻辑修改', 'HDFS-13638、HDFS-10453、HDFS-13663、HDFS-14794'),
        (286, 338, 'Set Times API, updates negative time on all negative values apart from -1.', 'Set Times API, updates negative time on all negative values apart from -1.', 'HDFS-14529'),
        (287, 339, 'dfs.ha.tail-edits.qjm.rpc.max-txns配置默认为5000，超过时会出现失败', 'Bootstrap standby may fail if used in-progress tailing', ''),
        (288, 340, 'ec逻辑错误', 'ec:Block recovery failed during decommissioning', ''),
        (289, 341, 'the sequence of statistics & exit message in balencer 不正确', '更正顺序', ''),
        (290, 342, 'count 命令只考虑文件和目录而不考虑 inode 引用', 'Misleading REM_QUOTA value with snapshot and trash feature enabled for a directory', ''),
        (291, 343, '在 DFSNetworkTopology#chooseRandomWithStorageType()中增加检查 excludedNodes 是否包含范围。', '增加一个检查', ''),
        (292, 344, 'rename operation should check nest snapshot', '当我们进行重命名操作时，如果 src 目录或其任何后代是可快照的，并且 dst 目录或其任何祖先是可快照的，我们认为这是嵌套快照，应该被拒绝。', ''),
        (293, 345, '删除未使用的配置 dfs.web.authentication.filter', '在HADOOP-16314之后，这个配置没有在任何地方使用，所以我建议废除它以避免误用。', 'HADOOP-16314、HDFS-14609、HDFS-14609'),
        (294, 347, '当删除快照时，相应的数据结构不会被删除', '快照内存泄露', 'HDFS-14910'),
        (295, 349, '在路由器 Web UI 中，Observer NameNode信息显示为不可用', 'should show a proper icon for them', ''),
        (296, 350, 'DFSNetworkTopology#chooseRandomWithStorageType() 不应减少已属于排除范围的排除节点的存储计数', '计数错误', 'HDFS-14913'),
        (297, 351, '如果挂载表爆炸，我们应该支持 getListing(''/mnt'') 而不是在 dfs.federation.router.default.nameservice.enable 为 false 时抛出 IOException。', '挂载点的 LS 命令显示错误的所有者和权限信息。', ''),
        (298, 352, '加载编辑时，我们计算了时间，但后来在进行中的编辑（EditLogRailer 中的 doTailEdits()）被调用，它覆盖了加载的编辑时间', '在 NameNode Web UI 的 Startup Progress 页面中，Loading edits 总是显示 0 sec', ''),
        (299, 353, 'HADOOP-16558从构建要求中删除了协议缓冲区，但 libhdfspp 需要 libprotobuf 和 libprotoc。-如果未安装协议缓冲区，则Pnative构建失败。', '修复 hadoop-hdfs-native-client 的构建失败', 'HADOOP-16558'),
        (300, 354, '根本原因是FSOperations#contentSummaryToJSON没有将ContentSummary.erasureCodingPolicy解析为 json。', 'HttpFS：HttpFSFileSystem#getErasureCodingPolicy 始终返回 null', ''),
        (301, 355, '快照 Web UI 中的标题错误', '当显示快照列表时，标题是快照目录', ''),
        (302, 356, '代码逻辑问题', '启用 upgradeDomain 后，Namenode 可能无法复制块以满足策略', ''),
        (303, 357, '如果我们停止集群的所有数据节点，BlockPlacementPolicyDefault#chooseTarget 在调用#getMaxNodesPerRack 时可能会得到ArithmeticException，这会将运行时异常抛出到BlockManager 的ReplicationMonitor 线程，然后终止NN。', '停止所有 DataNode 可能导致 NN 终止', ''),
        (304, 358, 'ObserverNameNode 应该为不是来自 ObserverProxyProvider 的请求抛出 StandbyException', '代码逻辑错误，应该修改', ''),
        (305, 359, 'HDFS-14270在跟踪级别引入了客户端和服务器 StateId 的日志记录。不幸的是，其中一个参数alignmentContext.getLastSeenStateId()持有对 FSEdits 的锁定，即使禁用跟踪日志记录级别也会调用该锁定', '即使禁用跟踪日志记录级别也会调用该锁定', 'HDFS-14270'),
        (306, 360, '安全模式“forceExit”选项，未显示在帮助消息中', '安全模式“forceExit”选项，未显示在帮助消息中', ''),
        (307, 361, '原因是记录的值不是实际比较的值，日志对复制的和EC块都是一样的。理想情况下，它应该记录EC块的比较值，目前它记录的是内部块大小和块组大小', '如果块损坏的原因是日志大小不匹配。显示和比较的值不明确。', ''),
        (308, 362, 'dfsadmin triggerBlockReport 的文档在 HDFSCommands.md 中存在一个问题', '-namenode <namenode_host:ipc_port>是可选的。它应该是 [-namenode <namenode_host:ipc_port>]，而不是 [-namenode] <namenode_host:ipc_port>。', ''),
        (309, 364, '编辑文件已损坏，此错误的一个可能罪魁祸首是磁盘已满。JournalNode 无法恢复，必须从其他 JournalNode 手动重新同步。', 'JournalNode error: 不能扫描 pre-transactional edit log    ', ''),
        (310, 365, 'chooseTargetInOrder会抛出NotEnoughReplicasException，导致replication无法增加', '当 Block 预期的复制大于 DataNode 的数量时，进入维护将永远不会退出。', ''),
        (311, 366, '如果我们没有设置 dfs.namenode.audit.loggers（默认为 null），即使我们将 hadoop.caller.context.enabled 设置为 true，DefaultAuditLogger 也不会将 CallerConext 打印到 audit.log 中。', 'DefaultAuditLogger 不打印 CallerContext', ''),
        (312, 369, '在 ErasureCodingWork/ReplicationWork 中定义 LOG 而不是 BlockManager.LOG', 'BlockManager.LOG 有太多嘈杂的日志，很难调试问题', ''),
        (313, 370, 'macos hdfs.c 不兼容 jlong', '本机构建在macos上失败', ''),
        (314, 371, '实际上，如果指定了有利的节点，存储类型就会在有利的节点中选择BPP，一旦有利的节点用完，它就会从一开始就回到现有的BPP，而不考虑已经选择的存储类型，它只是把剩余的目标数向前推进', '使用 DistributedFileSystem.create(..favoredNodes) 写入数据时将违反 ONE_SSD 策略', ''),
        (315, 372, '挂载点的HdfsFileStatus在RBF中有一个空符号链接', 'FileStatus#toString() 将抛出 IllegalArgumentException', ''),
        (316, 374, '从 namenode 中删除多余的超级用户权限检查', '简化检查', ''),
        (317, 375, '当excludedNode不存在时，DFSNetworkTopology#chooseRandomWithStorageType()抛出NPE', '空指针异常', ''),
        (318, 376, 'mkdir 中的日志记录更改', 'TestHDFSCLI 和 TestDFSShell 测试中断', ''),
        (319, 378, 'HDFS-13699将调试日志行更改为信息日志行，并在hadoop fs -cat操作期间打印此行', '这使得很难确定日志行的结束位置和 catted 文件的开始位置，尤其是在将输出发送到工具进行解析时。', 'HDFS-13699'),
        (320, 379, '即使安全路由器无法创建DelegationTokenSecretManager，它也可以启动并继续运行', '此路由器无法处理带有委托令牌的请求，因此在这种情况下它不应该启动。', ''),
        (321, 380, 'dfs.ha.zkfc.port 属性在 hdfs-default.xml 中重复', '“dfs.ha.zkfc.port”属性配置在 hdfs-default.xml 文件中重复，具有通用值（端口号 - 8019）和不同的描述。', ''),
        (322, 381, 'remoteException在invoke方法中被解包，而在invokeMethod中它将是proxyOpComplete（false）。', '在FederationRPCPerformanceMonitor中，当返回RemoteException时，ProxyOpComplete并不准确。', ''),
        (323, 382, '当前代码逻辑中，除非显式加载类才会加载hdfs-rbf-site.xml', 'hdfs-rbf-site.xml 无法自动加载', ''),
        (324, 383, '当 getFileInfoAll 出现 IOException 时，我们应该返回 mountTable 信息而不是 super 信息', '抛出异常信息错误', ''),
        (325, 384, 'isParentEntry参数错误', 'MountTableResolver 无法正确使缓存无效', ''),
        (326, 385, '当文件在多个目标中打开时，IsFileClosed 应该返回 false，而不是抛出FileNotFoundException。', '异常的错误处理', ''),
        (327, 386, '当文件在多个目的地打开时，RecoverLease 应该返回 false', '异常的错误处理', ''),
        (328, 387, 'HAState中的prepareToEnterState是在没有锁定上下文的情况下被调用的。但在NameNode#NameNode中，prepareToEnterState是在haContext.writeLock()之后。', 'HAState#prepareToEnterState不需要上锁', ''),
        (329, 388, 'BlockManagerSafeMode 对安全模式阈值的解析错误。', '它将浮点值存储在 double 中，这将在一段时间内给出不同的结果。如果我们以双精度存储“0.999f”值，那么它将转换为“0.9990000128746033”。', ''),
        (330, 389, 'ClosedChannelException 在 FsVolumeList.addBlockPool() 中被忽略', '需要重构以捕获在 addBlockPool 中引发的任何 AddBlockPoolException，然后在重新抛出任何捕获的异常之前继续调用 getAllVolumesMap() 以允许 DN 处理单个卷故障', ''),
        (331, 390, '在 LocalReplica#parseBaseDir() 中，“子目录”被忽略了。', 'DirectoryScanner 扫描块文件时，如果块引用的块文件不存在，DirectoryScanner 将根据在磁盘上找到的副本文件更新块,但是 DirectoryScanner 并没有真正修复它', ''),
        (332, 391, 'explorer.js#modal-upload-file-button目前不能与knox一起工作。该函数对完整的URL进行编码，因此创建了一个畸形的URL。', '导致上传文件时出现错误。', ''),
        (333, 392, 'WebHDFS 抛出“将请求正文写入服务器时出错”而不是 DSQuotaExceededException', '当通过WebHDFS向HDFS写入数据时，一个配额异常被返回给客户端。对于用户来说，这个异常是由于他们超过了配额而引起的，这一点是完全不透明的，但在DataNode的日志中却会直接输出内容。', ''),
        (334, 393, '如果 targetPath 不存在，updateMountTableEntry 不应更新 mountTableEntry', '如果 synchronizeQuota 抛出一些异常，会返回一些异常给 dfsRouterAdmin，但是新的 mountEntry 已经更新到 zk。  ', ''),
        (335, 394, 'TestDataNodeHotSwapVolumes#testAddVolumesConcurrently 在trunk中间歇性失败', '抛出NPE', ''),
        (336, 395, 'HDFS-14053向 blockManager 引入了一个方法“processMisReplicatedBlocks”，fsck 使用它来调度错误复制的块进行复制。', '方法应该返回它处理的块数，但它总是返回零，因为“已处理”在方法中永远不会增加。它还应该在每个“numBlocksPerIteration”中丢弃并重新获取写锁，但由于处理过程永远不会增加，它永远不会丢弃并重新获取写锁，从而有可能长时间持有写锁。', 'HDFS-14053'),
        (337, 396, '格式化 JN 时不会清除日志编辑缓存', '应该清楚缓存', ''),
        (338, 397, '目前，当 NN 转换为活动状态时，它会中断 EditLogTailer 并输出完整的堆栈跟踪。', 'EditLogTailer 在中断时不应输出完整的堆栈跟踪', ''),
        (339, 398, '当前在备用 NN 上处理 setReplication 会导致日志记录。', '应当禁止', ''),
        (340, 399, '1. 重构后的代码中，''off''参数已经完全去掉，表示不需要它，但现在使用''len''。2.在2.x代码中，off和len是方法的参数，但从未使用过，我认为需要使用“len”，否则会导致这个bug。', '在Hadoop 2中，当一个文件在加密区被打开进行写入，拍摄快照并追加时，快照中读出的文件大小要比列表大小大。这种情况即使在启用了不可更改的快照HDFS-11402时也会发生。', 'HDFS-11402'),
        (341, 400, 'HDFS-14304在创建环境之后但在检查它是否为空之前，在 getJNIEnv 中添加了对 initCachedClasses 的调用。在getJNIEnv()创建环境失败的情况下，它返回NULL，然后我们在第555行调用initCachedClasses()时崩溃', '使用带有错误类路径的 libhdfs 时崩溃', 'hdfs-14304'),
        (342, 402, '虽然 Standby 允许getHAServiceState()调用，但在 Standby 状态下不允许读取委托令牌，因此在使用基于 DT 的身份验证时调用会失败', 'ObserverReadProxyProvider 无法从备用 NN 正确获取 HAState', ''),
        (343, 403, 'TestTrySendErrorReportWhenNNThrowsIOException 在trunk中失败', '测试失败', ''),
        (344, 404, 'HDFS-14327添加了 dfs.client.failover.resolver.useFQDN 并且它破坏了 TestHdfsConfigFields。', '需要修复字段 dfs.client.failover.resolver.useFQDN 的 TestHdfsConfigFields', 'HDFS-14327'),
        (345, 405, '目前在实例化类时设置 Datanode 的开始时间', '但理想情况下，它应该仅在 RPC 服务器启动并且初始化 RPC 处理程序以服务客户端请求之后设置', ''),
        (346, 406, '修复 hadoop 网站发布说明和变更日志不可用', '修复 hadoop 网站发布说明和变更日志不可用', ''),
        (347, 408, 'OfflineEditsXmlLoader 中不安全的 Xml 解析', '安全性问题', ''),
        (348, 409, '应该将StaticRouterRpcFairnessPolicyController更改为为并发 ns 分配额外的处理程序，以防它被配置。', '如果 配置了 dfs.federation.router.fairness.handler.count.concurrent，则 unassignedNS 为空并且 handlerCount % unassignedNS.size()将抛出 /0 异常。', ''),
        (349, 410, '`dfs.namenode.acls.enabled`在HDFS-13505之后被默认设置为`true`。', '可以改进文档以避免混淆', 'HDFS-13505'),
        (350, 411, '`dfs.disk.balancer.enabled`在HDFS-13153之后被默认启用', '可以改进文档以避免混淆', 'HDFS-13153'),
        (351, 413, '纠正pmem缓存的声明，以反映缓存的持久性支持', '改进文档', ''),
        (352, 415, '在 BlockInfo#getPrevious 和 BlockInfo#getNext 两种方法中，断言消息都是错误的。', '这可能会引起一些误解，需要纠正。', ''),
        (353, 417, 'daemonlog 的示例命令不正确', 'getlevel 命令包含日志级别，这会导致命令失败。只有 setlevel API 需要 Loglevel。', ''),
        (354, 419, 'Util#receiveFile 中的写入文件时间计算错误。', '时间错误', ''),
        (355, 420, '完善ProtobufRpcEngine2#Server()相关参数注释', '目前缺少对 numReaders、queueSizePerHandler 和 secretManager 的描述', ''),
        (356, 422, '增加TestBootstrapStandby、TestFsVolumeList和TestDecommissionWithBackoffMonitor的超时时间', '单元测试超时', ''),
        (357, 423, '我们在getBlockLocations()中使用比较器对位置进行排序，预期的结果是：live -> stale -> entering_maintenance -> decommissioned。但是networktopology. SortByDistance()会打乱这个顺序。我们还应该在networktopology.SortByDistance()之前过滤掉状态为AdminStates.Entering_MAINTENANCE的节点。SortByDistance()。', '排序错误', ''),
        (358, 424, '回滚 HDFS 集群时，JNStorage 中的属性在存储目录更改后不会刷新。', '启动namenode时会导致异常。', ''),
        (359, 425, '如果没有数据包确认（来自数据节点），我们必须中断 DataStreamer。它可能发生在基础设施/网络问题上。', 'HiveServer2 由于 DataStreamer#waitForAckedSeqno 而停止', ''),
        (360, 427, 'hdfs fsck -list-corruptfileblocks 命令的输出信息不正确', '造成误导', ''),
        (361, 432, '改进缺少“dfs.namenode.rpc-address.$NAMESERVICE”的错误消息', '错误消息告诉我应该设置 `dfs.namenode.rpc-address` 或 `dfs.namenode.servicerpc-address`。但是，错误的实际原因是 `dfs.namenode.rpc-address.ns1` 或 `dfs.namenode.servicerpc-address.ns1` 未设置。', ''),
        (362, 433, '连接安全 hdfs 的 webhdfs 不应使用 user.name 参数', '使用 B.COM webhdfs 的 user_a@A.COM 的 hdfs dfs 命令失败。', ''),
        (363, 434, '代码逻辑问题', '失败卷的数量与 Datanode 指标的 volumeFailures 不匹配,Datanode 的指标只会增加 1，即使在磁盘检查期间有多个卷失败。', ''),
        (364, 435, '测试线程和 LeaseRenewer 线程之间的竞争，', 'TestDFSClientRetries#testLeaseRenewSocketTimeout间歇性地失败', ''),
        (365, 438, 'FSVolumeImpl.initializeCacheExecutor 调用 Guava 的 ThreadPoolExecutorBuilder。setNameFormat，传入父文件的字符串表示。Guava 将获取整个字符串并将其传递给 String.format，它使用 % 作为特殊字符。这意味着如果 parent.toString() 包含一个百分号，后跟一个在 String.format() 中非法用作格式化程序的字符，您将收到一个阻止 MiniCluster 启动的异常。', 'HDFS MiniCluster 在带有 % 的目录路径中运行时无法启动', ''),
        (366, 440, '现在，当做listOpenFiles()时，LeaseManager只检查过滤器路径是否是开放文件的前缀', '我们应该检查过滤器的路径是否是开放文件的parent/ancestor。', ''),
        (367, 442, 'DFSConfigKeys.DFS_USE_DFS_NETWORK_TOPOLOGY_KEY默认为true，CommonConfigurationKeysPublic.NET_TOPOLOGY_IMPL_KEY被忽略，测试实际上使用默认的DFSNetworkTopology。', 'TestBalancerWithNodeGroup是用来测试NetworkTopologyWithNodeGroup的，但它的配置并不正确。', ''),
        (368, 443, '当仅运行 TestPendingReconstruction#testPendingReconstruction() 的 UT 时，它将失败并抛出 NullPointerException。', '抛出NPE', ''),
        (369, 444, '应该不允许设置 balancer 最大网络带宽超过 1TB', '用setBalancerBandwidth命令设置平衡器的带宽，数值为[1048576000g/1048p/1e] 。 在HDFS块平衡过程中，用命令: hdfs dfsadmin -getBalancerBandwidth 检查数据节点使用的带宽，它将显示一些不同的值，而不是设置的值', ''),
        (370, 445, 'rbf协议类中的 proto.getClass().getName() 应该是 proto.getName()', '接口使用错误', ''),
        (371, 446, '对于管道中的一个数据节点，当其PacketResponder线程遇到异常时，打出的日志是错误的', '具有误导性的日志', ''),
        (372, 447, 'RBF：“hdfs dfsrouteradmin -ls”的输出中缺少换行符', '输出格式不易阅读', ''),
        (373, 452, '在 DatanodeDescriptor 中同步 invalidateBlocks', '这不是必要的，但这么做会更安全', ''),
        (374, 453, '目前 RBF 的 WebUI 在其标题中使用 <ROUTER FQDN>:<HTTP port>。应该改成<ROUTER FQDN>:<RPC port>，就像NameNode和DataNode的WebUI一样', '在 RBF Web UI 中显示 RPC（而不是 HTTP）端口号', ''),
        (375, 456, '命令提示不完整', '命令 hadoop fs -test 支持七个选项：-d / -e / -f / -s / -w / -r / -z。但是当看到这个命令的用法时，只看到五个选项。w 和 r 丢失。', ''),
        (376, 457, 'TestDirectoryScanner#testDirectoryScannerInFederatedCluster 在trunk中间歇性失败', '因写入同名文件而失败，意味着打算写入 2 个文件但 2 个文件同名，这会导致数据节点删除块的竞争条件和扫描动作计数块', ''),
        (377, 459, '最近，我们将 hadoop 库从 2.7.7 升级到了 3.2.0。', '此问题发生在更新后。当我们使用位置 ''webhdfs://hadoop-master:50070/user/hive/warehouse/test_part/dt=1'' 调用 FileSystem.listLocatedStatus 时，内部调用两个版本不兼容', 'HDFS-14323'),
        (378, 460, '一些 throw 语句中的异常类没有准确描述它们被抛出的原因', '抛出一般的IOException使得在元数据文件损坏时很难执行数据恢复。', ''),
        (379, 464, '删除 TestStorageRestore 中不相关的 trim() 调用', '字符串是不可变的，您需要使用 trim() 方法返回值。', ''),
        (380, 471, 'doc中对RBFMetrics的小修正', '文档更改', ''),
        (381, 472, '修复 Observer NameNode 文档中的错字', '修复 Observer NameNode 文档中的错字', '');